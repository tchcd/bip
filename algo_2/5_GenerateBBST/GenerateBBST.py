
"""

для любой вершины дерева глубина её двух поддеревьев различается не более чем на единицу.
 высота дерева всегда равна логарифму от количества элементов в дереве. 
 Эта особенность помогает обеспечить эффективное выполнение операций поиска, вставки и удаления
"""

"""
Напишите функцию GenerateBBSTArray(), которая получает на вход неотсортированный массив,
по размеру соответствующий полностью заполненному дереву некоторой положительной глубины, 
и выдаёт на выходе массив, содержащий структуру сбалансированного BST.

сортируем исходный массив за O(N * log N), и затем за O(N) строим из него сбалансированное BST.
"""


"""
Рекурсивное формирование сбалансированного BST (точнее, массива для BST) происходит так:

1. Выбираем центральный элемент исходного отсортированного массива, и делаем его корневым 
(на первом шаге помещаем его в нулевой элемент итогового массива).

2. Для левой части по отношению к выбранному элементу повторяем этот алгоритм 
-- индекс корневого элемента левой части будет равен индексу левого наследника корня из пункта 1.

3. Для правой части по отношению к выбранному элементу повторяем этот алгоритм 
-- индекс корневого элемента правой части будет равен индексу правого наследника корня из пункта 1.
"""
def get_elements(array_left, array_right, res):
	l = len(array_left) // 2
	r = len(array_right) // 2
	if l == 0:
		res.append(array_left[0])
	else:
		res.append(array_left[l])

	if r == 0:
		res.append(array_right[0])
	else:
		res.append(array_right[r])

	if l > 0:
		get_elements(array_left[:l], array_left[l+1:], res)

	if r > 0:
		get_elements(array_right[:r], array_right[r + 1:], res)

	return res


def GenerateBBSTArray(a):
	a = sorted(a)
	res = []

	idx = len(a) // 2
	res.append(a[idx])

	left = a[:idx]
	right = a[idx+1:]

	return get_elements(left, right, res)

if __name__ == '__main__':
	arr = [1, 4, 7, 5, 3, 9, 8] # []
	print(GenerateBBSTArray(arr))
